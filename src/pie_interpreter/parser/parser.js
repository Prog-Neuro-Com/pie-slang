"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pieDeclarationParser = exports.DefineTactically = exports.SamenessCheck = exports.Definition = exports.Claim = exports.Parser = void 0;
exports.syntaxToLocation = syntaxToLocation;
exports.schemeParse = schemeParse;
var scheme_lexer_1 = require("../../scheme_parser/transpiler/lexer/scheme-lexer");
var scheme_parser_1 = require("../../scheme_parser/transpiler/parser/scheme-parser");
var scheme_node_types_1 = require("../../scheme_parser/transpiler/types/nodes/scheme-node-types");
var locations_1 = require("../utils/locations");
var utils_1 = require("../types/utils");
var Maker = require("./makers");
// ### Helper functions
function syntaxToLocation(syntax) {
    return new locations_1.Location(syntax, true);
}
function syntaxToSiteBinder(syntax) {
    return new utils_1.SiteBinder(syntaxToLocation(syntax), syntax.source);
}
function getValue(element) {
    if (element instanceof scheme_node_types_1.Atomic.Symbol) {
        return element.value;
    }
    else if (element instanceof scheme_node_types_1.Atomic.NumericLiteral) {
        return element.value;
    }
    else if (element instanceof scheme_node_types_1.Extended.List) {
        return getValue(element.elements[0]);
    }
    else {
        throw new Error('Expected a Element, but got: ' + element);
    }
}
function locationToSyntax(source, location) {
    return new locations_1.Syntax(location.start, location.end, source);
}
function elementToSyntax(element, location) {
    return locationToSyntax(getValue(element), location);
}
// ### Parser
// The parser class is responsible for parsing the AST generated by the SchemeParser
function schemeParse(stx) {
    var lexer = new scheme_lexer_1.SchemeLexer(stx);
    var parser = new scheme_parser_1.SchemeParser('', lexer.scanTokens());
    var ast = parser.parse();
    return ast;
}
var Parser = /** @class */ (function () {
    function Parser() {
    }
    Parser.parsePie = function (stx) {
        return Parser.parseElements(schemeParse(stx)[0]);
    };
    Parser.parseElements = function (element) {
        var _this = this;
        var parsee = getValue(element);
        if (parsee === 'U') {
            return Maker.makeU(locationToSyntax('U', element.location));
        }
        else if (parsee === 'the') {
            var elements = element.elements;
            var loc = element.location;
            return Maker.makeThe(locationToSyntax('the', loc), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'Nat') {
            return Maker.makeNat(locationToSyntax('Nat', element.location));
        }
        else if (parsee === 'zero') {
            return Maker.makeZero(locationToSyntax('zero', element.location));
        }
        else if (parsee === 'add1') {
            return Maker.makeAdd1(locationToSyntax('add1', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === '->' || parsee === '→') {
            var elements = element.elements;
            var loc = element.location;
            return Maker.makeArrow(locationToSyntax('->', loc), [
                this.parseElements(elements[1]),
                this.parseElements(elements[2]),
                elements.slice(3).map(function (x) { return _this.parseElements(x); })
            ]);
        }
        else if (parsee === 'lambda' || parsee === 'λ') {
            var elements = element.elements;
            var loc = element.location;
            var args = elements[1];
            var body = elements[2];
            return Maker.makeLambda(locationToSyntax('λ', loc), args.elements.map(function (x) {
                return syntaxToSiteBinder(elementToSyntax(x, element.location));
            }), this.parseElements(body));
        }
        else if (parsee === 'Pi' || parsee === 'Π') {
            var elements = element.elements;
            var args = elements[1];
            var body = elements[2];
            // Get first binding pair
            var firstPair = args.elements[0];
            var x0 = firstPair.elements[0];
            var A0 = firstPair.elements[1];
            // Process remaining binding pairs
            var remainingPairs = args.elements.slice(1);
            var processedPairs = remainingPairs.map(function (pair) {
                var x = pair.elements[0];
                var A = pair.elements[1];
                return new utils_1.TypedBinder(syntaxToSiteBinder(elementToSyntax(x, pair.location)), _this.parseElements(A));
            });
            return Maker.makePi(locationToSyntax('Π', element.location), Maker.makeTypedBinders(new utils_1.TypedBinder(syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)), this.parseElements(A0)), processedPairs), this.parseElements(body));
        }
        else if (parsee === 'Sigma' || parsee === 'Σ') {
            var elements = element.elements;
            var args = elements[1];
            var body = elements[2];
            // Get first binding pair
            var firstPair = args.elements[0];
            var x0 = firstPair.elements[0];
            var A0 = firstPair.elements[1];
            // Process remaining binding pairs
            var remainingPairs = args.elements.slice(1);
            var processedPairs = remainingPairs.map(function (pair) {
                var x = pair.elements[0];
                var A = pair.elements[1];
                return new utils_1.TypedBinder(syntaxToSiteBinder(elementToSyntax(x, pair.location)), _this.parseElements(A));
            });
            return Maker.makeSigma(locationToSyntax('Π', element.location), Maker.makeTypedBinders(new utils_1.TypedBinder(syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)), this.parseElements(A0)), processedPairs), this.parseElements(body));
        }
        else if (parsee === 'Pair') {
            var elements = element.elements;
            return Maker.makePair(locationToSyntax('Pair', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'cons') {
            var elements = element.elements;
            return Maker.makeCons(locationToSyntax('Cons', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'car') {
            return Maker.makeCar(locationToSyntax('car', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'cdr') {
            return Maker.makeCdr(locationToSyntax('cdr', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'which-Nat') {
            var elements = element.elements;
            return Maker.makeWhichNat(locationToSyntax('which-Nat', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'iter-Nat') {
            var elements = element.elements;
            return Maker.makeIterNat(locationToSyntax('iter-Nat', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'rec-Nat') {
            var elements = element.elements;
            return Maker.makeRecNat(locationToSyntax('rec-Nat', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'ind-Nat') {
            var elements = element.elements;
            return Maker.makeIndNat(locationToSyntax('ind-Nat', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]), this.parseElements(elements[4]));
        }
        else if (parsee === 'Atom') {
            return Maker.makeAtom(locationToSyntax('Atom', element.location));
        }
        else if (parsee === 'quote') {
            return Maker.makeQuote(locationToSyntax('Quote', element.location), getValue(element.elements[1]));
        }
        else if (parsee === 'Trivial') {
            return Maker.makeTrivial(locationToSyntax('Trivial', element.location));
        }
        else if (parsee === 'sole') {
            return Maker.makeSole(locationToSyntax('sole', element.location));
        }
        else if (parsee === 'List') {
            return Maker.makeList(locationToSyntax('List', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'nil') {
            return Maker.makeNil(locationToSyntax('nil', element.location));
        }
        else if (parsee === '::') {
            var elements = element.elements;
            return Maker.makeListCons(locationToSyntax('::', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'rec-List') {
            var elements = element.elements;
            return Maker.makeRecList(locationToSyntax('rec-List', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'ind-List') {
            var elements = element.elements;
            return Maker.makeIndList(locationToSyntax('ind-List', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]), this.parseElements(elements[4]));
        }
        else if (parsee === '=') {
            var elements = element.elements;
            return Maker.makeEqual(locationToSyntax('=', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'same') {
            return Maker.makeSame(locationToSyntax('same', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'replace') {
            var elements = element.elements;
            return Maker.makeReplace(locationToSyntax('replace', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'trans') {
            var elements = element.elements;
            return Maker.makeTrans(locationToSyntax('trans', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'cong') {
            var elements = element.elements;
            return Maker.makeCong(locationToSyntax('cong', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'ind-=') {
            var elements = element.elements;
            return Maker.makeIndEqual(locationToSyntax('ind-=', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'symm') {
            return Maker.makeSymm(locationToSyntax('symm', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'Vec') {
            var elements = element.elements;
            return Maker.makeVec(locationToSyntax('Vec', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'vecnil') {
            return Maker.makeVecNil(locationToSyntax('vecnil', element.location));
        }
        else if (parsee === 'vec::') {
            var elements = element.elements;
            return Maker.makeVecCons(locationToSyntax('vec::', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'head') {
            return Maker.makeHead(locationToSyntax('head', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'tail') {
            return Maker.makeTail(locationToSyntax('tail', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'ind-Vec') {
            var elements = element.elements;
            return Maker.makeIndVec(locationToSyntax('ind-Vec', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]), this.parseElements(elements[4]), this.parseElements(elements[5]));
        }
        else if (parsee === 'Either') {
            var elements = element.elements;
            return Maker.makeEither(locationToSyntax('Either', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'left') {
            return Maker.makeLeft(locationToSyntax('left', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'right') {
            return Maker.makeRight(locationToSyntax('right', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'ind-Either') {
            var elements = element.elements;
            return Maker.makeIndEither(locationToSyntax('ind-Either', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]), this.parseElements(elements[4]));
        }
        else if (parsee === 'Absurd') {
            return Maker.makeAbsurd(locationToSyntax('Absurd', element.location));
        }
        else if (parsee === 'ind-Absurd') {
            var elements = element.elements;
            return Maker.makeIndAbsurd(locationToSyntax('ind-Absurd', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'TODO') {
            return Maker.makeTODO(locationToSyntax('TODO', element.location));
        }
        else if (element instanceof scheme_node_types_1.Extended.List && element.elements.length > 1) {
            var elements = element.elements;
            return Maker.makeApp(locationToSyntax('App', element.location), this.parseElements(elements[0]), this.parseElements(elements[1]), elements.slice(2).map(function (x) { return _this.parseElements(x); }));
        }
        else if ((0, utils_1.isVarName)(parsee)) {
            return Maker.makeVarRef(locationToSyntax(parsee, element.location), parsee);
        }
        else if (!isNaN(Number(parsee))) { // numeric literal
            return Maker.makeNatLiteral(locationToSyntax(parsee, element.location), parsee);
        }
        throw new Error('Unexpected element: ' + element);
    };
    Parser.parseToTactics = function (element) {
        var parsee = getValue(element);
        if (parsee === 'exact') {
            return Maker.makeExact(locationToSyntax('exact', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'intro') {
            return Maker.makeIntro(locationToSyntax('intro', element.location), element.elements[1].value);
        }
        else if (parsee === 'exists') {
            return Maker.makeExists(locationToSyntax('exists', element.location), this.parseElements(element.elements[1]), element.elements[2].value);
        }
        else if (parsee === 'elimNat') {
            return Maker.makeElimNat(locationToSyntax('elimNat', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        else if (parsee === 'elimList') {
            return Maker.makeElimList(locationToSyntax('elimList', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        else if (parsee === 'elimVec') {
            return Maker.makeElimVec(locationToSyntax('elimVec', element.location), element.elements[1].value, this.parseElements(element.elements[2]), this.parseElements(element.elements[3]));
        }
        else if (parsee === 'elimEqual') {
            return Maker.makeElimEqual(locationToSyntax('elimEqual', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        else if (parsee === 'left') {
            return Maker.makeLeftTactic(locationToSyntax('left', element.location));
        }
        else if (parsee === 'right') {
            return Maker.makeRightTactic(locationToSyntax('right', element.location));
        }
        else if (parsee === 'elimEither') {
            return Maker.makeElimEither(locationToSyntax('elimEither', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        else if (parsee === 'split') {
            return Maker.makeSplit(locationToSyntax('split', element.location));
        }
        else if (parsee === 'elimAbsurd') {
            return Maker.makeElimAbsurd(locationToSyntax('elimAbsurd', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        throw new Error('Unexpected tactic: ' + element);
    };
    return Parser;
}());
exports.Parser = Parser;
// ### Helper functions for parsing the AST
var Claim = /** @class */ (function () {
    function Claim(location, name, type) {
        this.location = location;
        this.name = name;
        this.type = type;
    }
    return Claim;
}());
exports.Claim = Claim;
var Definition = /** @class */ (function () {
    function Definition(location, name, expr) {
        this.location = location;
        this.name = name;
        this.expr = expr;
    }
    return Definition;
}());
exports.Definition = Definition;
var SamenessCheck = /** @class */ (function () {
    function SamenessCheck(location, type, left, right) {
        this.location = location;
        this.type = type;
        this.left = left;
        this.right = right;
    }
    return SamenessCheck;
}());
exports.SamenessCheck = SamenessCheck;
var DefineTactically = /** @class */ (function () {
    function DefineTactically(location, name, tactics) {
        this.location = location;
        this.name = name;
        this.tactics = tactics;
    }
    return DefineTactically;
}());
exports.DefineTactically = DefineTactically;
var pieDeclarationParser = /** @class */ (function () {
    function pieDeclarationParser() {
    }
    pieDeclarationParser.parseDeclaration = function (ast) {
        var parsee = getValue(ast);
        if (parsee === 'claim') {
            var elements = ast.elements;
            return new Claim(syntaxToLocation(elementToSyntax(elements[0], ast.location)), getValue(elements[1]), Parser.parseElements(elements[2]));
        }
        else if (parsee === 'define') {
            var elements = ast.elements;
            return new Definition(syntaxToLocation(elementToSyntax(elements[0], ast.location)), getValue(elements[1]), Parser.parseElements(elements[2]));
        }
        else if (parsee === 'check-same') {
            var elements = ast.elements;
            return new SamenessCheck(syntaxToLocation(elementToSyntax(elements[0], ast.location)), Parser.parseElements(elements[1]), Parser.parseElements(elements[2]), Parser.parseElements(elements[3]));
        }
        else if (parsee === 'define-tactically') {
            var elements = ast.elements;
            return new DefineTactically(syntaxToLocation(elementToSyntax(elements[0], ast.location)), getValue(elements[1]), elements[2].elements.map(function (x) { return Parser.parseToTactics(x); }));
        }
        else {
            return Parser.parseElements(ast);
        }
    };
    return pieDeclarationParser;
}());
exports.pieDeclarationParser = pieDeclarationParser;
